import dash
import dash_mantine_components as dmc
from dash import html  # Mise à jour pour Dash 1.0+
from dash.dependencies import Input, Output, State
import subprocess

app = dash.Dash(__name__)

app.layout = dmc.Card(
    children=[
        html.Div(id="stdout"),
        dmc.Group(
            children=[
                dmc.Checkbox(id=f"checkbox-{i}", label=host, value=False) for i, host in enumerate(["google.com", "scanme.nmap.org", "20.199.91.129"])
            ],
            spacing="xs",
            align="start",
        ),
        dmc.Button(id="button", children="Valider et lancer les commandes"),
    ],
)

@app.callback(
    Output("button", "disabled"),
    [Input(f"checkbox-{i}", "checked") for i in range(3)],
)
def update_button_state(*checkboxes):
    return not any(checkboxes)

@app.callback(
    Output("button", "children"),
    [Input(f"checkbox-{i}", "checked") for i in range(3)],
)
def update_button_label(*checkboxes):
    return "Valider et lancer les commandes" if any(checkboxes) else "Aucune cible sélectionnée"

@app.callback(
    Output("stdout", "children"),
    [Input("button", "n_clicks")],  # Déclenché par le clic sur le bouton
    [State(f"checkbox-{i}", "checked") for i in range(3)]  # Récupère l'état des checkboxes au moment du clic
)
def run_nmap(n_clicks, *checkbox_states):
    if n_clicks is None:
        return "Cliquez sur le bouton pour exécuter les commandes."

    # Liste des hôtes correspondant à chaque checkbox
    hosts = ["google.com", "scanme.nmap.org", "20.199.91.129"]

    # Vérifie si au moins une checkbox est cochée
    if not any(checkbox_states):
        return "Aucune cible sélectionnée. Sélectionnez au moins une option."

    # Exécute `nmap` pour chaque hôte sélectionné
    output_messages = []
    for checkbox_state, host in zip(checkbox_states, hosts):
        if checkbox_state:  # Si la checkbox est cochée
            try:
                result = subprocess.run(["nmap", "-sV", host], capture_output=True, text=True)
                output_messages.append(f"Résultat pour {host} :\n{result.stdout}")
            except Exception as e:
                output_messages.append(f"Erreur lors de l'exécution de la commande pour {host}: {e}")

    # Affiche les résultats
    return html.Pre("\n\n".join(output_messages))


if __name__ == "__main__":
    app.run_server(debug=True)
