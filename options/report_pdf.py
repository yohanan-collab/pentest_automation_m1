import re
import sys
from colorama import Fore, Style
from fpdf import FPDF, HTMLMixin
import requests
from tabulate import tabulate

from options.new_scan import Nmap



# def report_pdf():
#     try:
#         target = input(Fore.YELLOW + ">>> Enter the target\n>>> ")

#         # Utilisation de NmapHostDiscovery au lieu de Nmap pour une meilleure lisibilité
#         results = Nmap(target)

#         if results:
#             headers = ["ID", "Port", "Service", "Version"]
#             formatted_results = [[i+1, result[1], result[2], result[3]] for i, result in enumerate(results)]
#             print(tabulate(formatted_results, headers=headers, tablefmt="grid"))
#         else:
#             print("No results found.")
#     except Exception as e:
#         print("An error occurred:", str(e))

def is_valid_url(url):
    regex = re.compile(
        r'^(?:http|ftp)s?://' # http:// or https://
        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+(?:[A-Z]{2,6}\.?|[A-Z0-9-]{2,}\.?)|' #domain...
        r'localhost|' #localhost
        r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})' # ip
        r'(?::\d+)?' # optional port
        r'(?:/?|[/?]\S+)$', re.IGNORECASE)
    return re.match(regex, url) is not None


########################################
#   lil Nikto scan
#######################################
def check_server(url, pdf):
    HTML = ""
    try:
        if is_valid_url(url):
            response = requests.get(url)
        else:
            print(">>> [!] Incorrect url format")
            sys.exit()
    except requests.exceptions.RequestException as e:
        print("Erreur lors de la requête : ", e)
        sys.exit(1)

    server = response.headers.get("Server")
    x_powered_by = response.headers.get("X-Powered-By")

    if server is not None:
        print(f">>> {Fore.GREEN}[+] Webserver is  : {server}{Style.RESET_ALL}")
        if pdf:
            HTML += f"<p>Web server : {server}<p>"
    if x_powered_by is not None:
        print(f">>> {Fore.GREEN}[+] Webserver uses :  {x_powered_by}{Style.RESET_ALL}")
        if pdf:
            HTML += f"<p>Server uses : {x_powered_by}</p>"

    # Vérifier si le serveur supporte la compression
    if "Content-Encoding" in response.headers:
        print(f">>> {Fore.YELLOW}[-] The server supports compression.{Style.RESET_ALL}")
        if pdf:
            HTML += f"<p>The server supports compression.</p>"
    else:
        print(f">>> {Fore.YELLOW}[-] The server doesn't support compression.{Style.RESET_ALL}")
        if pdf:
            HTML += f"<p>The server doesn't support compression.</p>"

    version_regex = re.compile(r"\d+\.\d+(\.\d+)?")
    for header in response.headers:
        match = version_regex.search(response.headers[header])
        if match:
            print(f">>> {Fore.GREEN}[+] Version of software might be found in the following header '{header}' : {match.group(0)} {Style.RESET_ALL}")
            if pdf:
                HTML += f"<p>Version of software might be found in the following header {header} : {match.group(0)}</p>"

    # Vérifier si l'URL cible redirige vers une autre URL
    if response.status_code in [301, 302]:
        loca_header = response.headers.get("Location")
        print(">>> [+] Target URL uses redirection towards : ", loca_header)
        if pdf:
            HTML += f"<p>Target URL uses redirection towards {loca_header}</p>"
    else:
        print(f">>> {Fore.YELLOW}[-] Target URL don't use any redirection{Style.RESET_ALL}")
        if pdf:
            HTML += f"<p>Target URL don't use any redirection</p>"

    # Vérifier si l'URL cible est protégée par une authentification basique HTTP
    if response.status_code == 401:
        print(">>> [+] Target URL is protected by a basic HTTP authentication")
        if pdf:
            HTML += f"<p>Target URL is protected by a basic HTTP authentication</p>"
    else:
        print(f">>> {Fore.YELLOW}[-] Target URL isn't protected by a basic HTTP authentication{Style.RESET_ALL}")
        if pdf:
            HTML += f"<p>Target URL isn't protected by a basic HTTP authentication</p>"

    #Others Nikto verifications
    headers = {
        "X-Frame-Options": "",
        "X-XSS-Protection": "",
        "X-Content-Type-Options": ""
    }

    try:
        response = requests.get(url, headers=headers)

        header1 = "The anti-clickjacking X-Frame-Options header is not present."
        header2 = "The X-XSS-Protection header is not defined."
        header3 = "The X-Content-Type-Options header is not set."

        if "X-Frame-Options" not in response.headers:
            print(f">>> {Fore.GREEN}[+] {header1}{Style.RESET_ALL}")
            HTML += f"<p>{header1}</p>"
        if "X-XSS-Protection" not in response.headers:
            print(f">>> {Fore.GREEN}[+] {header2}{Style.RESET_ALL}")
            HTML += f"<p>{header2}</p>"
        if "X-Content-Type-Options" not in response.headers:
            print(f">>> {Fore.GREEN}[+] {header3}{Style.RESET_ALL}")
            HTML += f"<p>{header3}</p>"
    except:
        print("Error occured while sending request to the URL")

    return HTML
from fpdf import FPDF, HTMLMixin


class PDF(FPDF):
    def header(self):
        self.set_font('Arial', 'B', 12)
        self.cell(0, 10, 'VULNERABILITY REPORT', 0, 1, 'C')

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Page {self.page_no()}', 0, 0, 'C')

def renderHTML(html):
    pdf = PDF()
    pdf.add_page()

    # Parse HTML for tags and styles
    tags = re.findall(r'<(.*?)>', html)
    styles = {}
    for tag in tags:
        style_match = re.search(r'style=["\'](.*?)["\']', tag)
        if style_match:
            styles[tag] = style_match.group(1)

    # Render HTML content with styles
    html_content = re.sub(r'<(.*?)>', '', html)
    pdf.set_font('Arial', '', 12)
    for line in html_content.split('\n'):
        for tag, style in styles.items():
            if tag in line:
                if 'text-align: center' in style:
                    pdf.cell(0, 10, line, 0, 1, 'C')
                elif 'text-align: right' in style:
                    pdf.cell(0, 10, line, 0, 1, 'R')
                else:
                    pdf.cell(0, 10, line)
                break

    pdf.output('result.pdf')
